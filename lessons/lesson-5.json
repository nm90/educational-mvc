{
  "id": 5,
  "title": "Understand Controllers",
  "description": "Learn how Controllers orchestrate between Models and Views, handling requests and coordinating data flow",
  "estimated_time": "12 min",
  "objectives": [
    "Understand the Controller's orchestration role",
    "See how Controllers coordinate multiple Models",
    "Learn the 'thin controller' principle",
    "Trace a complete request through the TaskController"
  ],
  "steps": [
    {
      "id": "5-1",
      "title": "What Do Controllers Do?",
      "content": "Controllers are the ORCHESTRATORS of your application. They don't do the actual work - they coordinate between the layers that do.\n\nController Responsibilities:\n1. Receive HTTP requests (via routes)\n2. Parse request data (form fields, URL parameters)\n3. Call Model methods to get/save data\n4. Handle errors from Models (validation failures, not found)\n5. Pass data to Views for rendering\n6. Return HTTP responses\n\nWhat Controllers Do NOT Do:\n- Database queries (Models handle those)\n- Validation logic (Models handle that)\n- HTML generation (Views handle that)\n- Business logic (Models handle that)\n\nOpen: backend/controllers/task_controller.py\n\nRead the docstring (lines 1-47) - it explains exactly what this Controller does and doesn't do.\n\nThe key insight: Controllers are THIN. They just connect things together.",
      "hint": "Read the docstring at the top of task_controller.py to understand the Controller's role",
      "checkpoint": null
    },
    {
      "id": "5-2",
      "title": "Trace the Index Request",
      "content": "Let's trace what happens when you load the task list.\n\nOpen: backend/controllers/task_controller.py, lines 81-121\n\nThe index() method handles GET /tasks:\n\n```python\n@tasks_bp.route('/', methods=['GET'])\n@log_method_call\ndef index():\n    # Call Model method to get all tasks\n    tasks = Task.get_all(include_relations=True)\n    \n    # Pass data to View template for rendering\n    return tracked_render_template('tasks/index.html', tasks=tasks)\n```\n\nNotice how SIMPLE this is! The Controller:\n1. Calls ONE Model method: Task.get_all()\n2. Passes result to ONE View: tasks/index.html\n3. That's it!\n\nThe Controller doesn't:\n- Write SQL queries\n- Validate data\n- Format HTML\n\nThis is the 'thin controller' principle in action.\n\nNow click 'View Tasks' and check the Developer Panel 'Method Call Stack'.\nYou'll see TaskController.index() calling Task.get_all().",
      "hint": "Load the task list and watch the Method Call Stack to see the Controller calling the Model",
      "devPanelHint": {
        "tab": "methods",
        "message": "Watch the Method Call Stack to see TaskController.index() calling Task.get_all() - simple orchestration!"
      },
      "checkpoint": null
    },
    {
      "id": "5-3",
      "title": "Multi-Model Coordination",
      "content": "Controllers often need to coordinate MULTIPLE Models.\n\nLook at the new() method (lines 176-217):\n\n```python\n@tasks_bp.route('/new', methods=['GET'])\n@log_method_call\ndef new():\n    # Load all users for owner and assignee dropdowns\n    users = User.get_all()\n    \n    # Render the form template with users for dropdowns\n    return tracked_render_template('tasks/new.html', users=users)\n```\n\nThis Controller method calls the User Model (not Task Model!) because:\n- The form needs a list of users for dropdown menus\n- Owner and Assignee fields are foreign keys to Users\n- Controller brings together data from different Models\n\nNow look at edit() method (lines 327-382):\n- Calls Task.get_by_id() to get the task to edit\n- Calls User.get_all() to populate dropdowns\n- Passes BOTH to the View\n\nThis is multi-model orchestration: the Controller coordinates multiple Models to prepare data for the View.\n\nClick 'Create Task' in the app and check the Method Call Stack.\nYou'll see TaskController.new() calling User.get_all().",
      "hint": "Click 'Create Task' and see how the Controller calls User.get_all() for the dropdown options",
      "devPanelHint": {
        "tab": "methods",
        "message": "Watch the Method Call Stack to see TaskController.new() calling TWO Models: Task and User"
      },
      "checkpoint": null
    },
    {
      "id": "5-4",
      "title": "Handling Model Errors",
      "content": "Controllers must handle errors from Models gracefully.\n\nLook at the create() method (lines 223-321):\n\n```python\ntry:\n    # Call Model to create task\n    task = Task.create(title, description, status, priority, owner_id, assignee_id)\n    flash('Task created successfully!', 'success')\n    return redirect(url_for('tasks.index'))\n\nexcept ValueError as e:\n    # Validation failed - Model raised an error\n    flash(str(e), 'error')\n    users = User.get_all()  # Re-load users for dropdowns\n    return tracked_render_template('tasks/new.html', users=users, ...)\n```\n\nThe pattern:\n1. Controller calls Model method\n2. Model validates and may raise ValueError\n3. Controller catches the error\n4. Controller re-renders form with error message\n\nNotice:\n- The Controller doesn't know WHY validation failed (that's Model's job)\n- The Controller just knows it failed and shows the error\n- The Controller re-loads users for dropdowns before re-rendering\n\nThis separation means validation rules can change in the Model without touching the Controller!",
      "hint": "Look at the try/except block in create() to see how Controllers handle Model errors",
      "devPanelHint": {
        "tab": "methods",
        "message": "See how TaskController.create() catches Model exceptions - try submitting invalid data"
      },
      "checkpoint": null
    },
    {
      "id": "5-5",
      "title": "The Show Pattern",
      "content": "Controllers often need to handle 'not found' cases.\n\nLook at the show() method (lines 127-170):\n\n```python\n@tasks_bp.route('/<int:task_id>', methods=['GET'])\n@log_method_call\ndef show(task_id):\n    # Call Model to get task by ID\n    task = Task.get_by_id(task_id, include_relations=True)\n    \n    # Handle not found case\n    if not task:\n        flash('Task not found', 'error')\n        return tracked_render_template('errors/404.html'), 404\n    \n    # Pass task data to View\n    return tracked_render_template('tasks/show.html', task=task)\n```\n\nThe pattern:\n1. Controller receives ID from URL\n2. Controller asks Model for that record\n3. Model returns the record OR None if not found\n4. Controller checks the result\n5. Controller either shows 404 OR renders the task\n\nThis is a common pattern you'll use in every Controller:\n- Check if Model returned None\n- Handle the not-found case appropriately\n- Otherwise proceed with the data\n\nClick on a specific task and check the Method Call Stack.",
      "hint": "Click on a task to see TaskController.show() calling Task.get_by_id()",
      "devPanelHint": {
        "tab": "methods",
        "message": "See TaskController.show() with the JOINed task data - notice the complete nested structure"
      },
      "checkpoint": null
    },
    {
      "id": "5-6",
      "title": "Controller Quiz",
      "content": "You've learned the key Controller concepts:\n\n1. Controllers ORCHESTRATE - they don't do the work themselves\n2. Controllers call MODEL methods for data operations\n3. Controllers pass data to VIEWS for rendering\n4. Controllers handle ERRORS from Models gracefully\n5. Controllers coordinate MULTIPLE Models when needed\n6. Controllers are THIN - minimal logic, maximum coordination\n\nRemember the flow:\n- Request comes in\n- Controller receives it\n- Controller calls Model(s)\n- Model(s) do the work, return data (or raise errors)\n- Controller passes data to View\n- View renders response\n- Controller returns response\n\nNow let's test your understanding!",
      "hint": "Think about which layer is responsible for each task",
      "checkpoint": {
        "type": "quiz",
        "question": "Which statement BEST describes a Controller's responsibility?",
        "options": [
          "Execute database queries and validate data",
          "Orchestrate between Models and Views",
          "Generate HTML and format output",
          "Define business rules and data structure"
        ],
        "correct": "Orchestrate between Models and Views"
      }
    }
  ]
}
